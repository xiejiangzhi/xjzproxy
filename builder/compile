#! /usr/bin/env ruby

require 'zlib'
require 'uri'
require_relative './help'

app_dir = File.expand_path('../../', __FILE__)
rbdata = {}
require 'openssl'
PUBLIC_KEY = OpenSSL::PKey::RSA.new(
  File.read(File.join(app_dir, 'licenses/license_key.pub'))
).to_der
LICENSE_REGEXP = /Xjz.LICENSE_CHECK\(([\w:'"]+)?\)/
ONLINE_LICENSE_REGEXP = /Xjz.LICENSE_ONLINE_CHECK/
EDITION_CONST_REGEXP = /Xjz::(TRL|STD|PRO)_ED/
APP_EDITION_REGEXP = /Xjz\.APP_EDITION/

def license_checker(edition)
  edition = edition.to_s.tr(':\'"', '').downcase
  code = <<~RUBY.lines.map(&:strip).join(';')
    lpath = $config['license_path']
    $LOADED_FEATURES.delete_if { |path| path['/openssl.'] }
    stderr = $stderr.dup
    $stderr.reopen('/dev/null')
    require 'openssl.so'
    $stderr.reopen(stderr)
    k = OpenSSL::PKey::RSA.new(#{mix_str(PUBLIC_KEY, 10, 10000)})
    id, e, ts, ex = k.public_decrypt(File.read(lpath)).split(',') rescue nil
    $config.data.merge!('.user_id' => id, '.edition' => e)
    tex = ex.to_f > 0 ? Time.at(ex.to_f) : nil
    $config.data.merge!('.license_ts' => Time.at(ts.to_f), '.license_ex' => tex)
    te = #{edition.inspect}
    (id && (te == e || te.empty?) && (tex.nil? || Time.now < tex)) ? true : false rescue false
  RUBY
  encode_code(code, 20, 60).strip
end

def license_online_checker
  uri = URI.parse('https://l.xjz.pw/v')
  code = <<~RUBY.lines.map(&:strip).join(';')
    lpath = $config['license_path']
    c = Xjz::ProxyClient::HTTP1.new(#{uri.host.inspect}, #{uri.port}, ssl: true).client
    ids = Gem::Platform.local.to_a[0..1] + [Socket.gethostname, Dir.home]
    id = OpenSSL::Digest::SHA256.hexdigest(ids.join(','))
    l = File.read(lpath) rescue nil
    if l
      Thread.new do
        r = c.post(#{uri.to_s.inspect}, l: l, id: id) { |req| req.options.timeout = 15 }
        json = JSON.parse(r.body) if r.status == 200
        if json && json['valid'] != true
          FileUtils.rm_rf(lpath)
        end
      end
    end
  RUBY
  encode_code(code, 20, 60).strip
end

def app_edition
  [
    "$config[#{mix_str('.edition', 3, 20, 1)}]",
    encode_code("$config['.edition']").strip
  ].sample
end

def edition_const(name)
  gblock = proc { |v| "(#{mix_str(v, 2, 20, 1)})" }
  case name
  when 'TRL' then gblock.call('trial')
  when 'PRO' then gblock.call('pro')
  when 'STD' then gblock.call('standard')
  else
    raise "invalid edition #{name}"
  end
end

def compile(path)
  code = File.read(path)
  lines = code.lines.each_with_object([]) do |line, r|
    next if line =~ /^\s*(#.*)?$/
    line.gsub!(/^\s+/, '')
    line.gsub!(LICENSE_REGEXP) { |s| license_checker($2.to_s.split(' ')) }
    line.gsub!(EDITION_CONST_REGEXP) { |s| edition_const($1) }
    line.gsub!(APP_EDITION_REGEXP) { |s| app_edition }
    line.gsub!(ONLINE_LICENSE_REGEXP) { license_online_checker }
    r << line
  end
  code = lines.join

  RubyVM::InstructionSequence.compile(
    code, path, path
  ).to_binary
end

Dir.chdir(app_dir) do
  Dir[*%w{*.rb src/xjz/**/*.rb}].each do |path|
    next if path == 'src/xjz/loader.rb'
    rbdata[path] = compile(path)
  end
  puts "Compiled Ruby Code"

  Dir[*%w{src/static/**/* src/webviews/**/*}].each do |path|
    next if File.directory?(path)
    rbdata[path] = File.read(path)
  end
  puts "Saved JS and Templates"
end

data = rbdata.map do |k, v|
  is_utf8 = v.encoding == Encoding::UTF_8 ? 1 : 0
  [
    [1, k.bytesize].pack("CN"), k,
    [is_utf8, v.bytesize].pack("CN"), v.force_encoding('binary')
  ].join
end.join

out_path = File.join(app_dir, 'data')
n = 9 + rand(128)
data = [
  [n].pack('C'),
  Random.bytes(n),
  Zlib::Deflate.deflate(data),
  Random.bytes(n)
].join
File.write(out_path, data)

puts "Output #{out_path}"

puts 'Done'
