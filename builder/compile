#! /usr/bin/env ruby

require 'zlib'
require_relative './help'

app_dir = File.expand_path('../../', __FILE__)
rbdata = {}
require 'openssl'
PUBLIC_KEY = OpenSSL::PKey::RSA.new(
  File.read(File.join(app_dir, 'licenses/license_key.pub'))
).to_der
LICENSE_REGEXP = /Xjz.LICENSE_CHECK\(([\w:'"]+)?\)/

def license_checker(edition)
  edition = edition.to_s.tr(':\'"', '').downcase
  code = <<~RUBY.lines.map(&:strip).join(';')
    lpath = $config['license_path']
    $LOADED_FEATURES.delete_if { |path| path['/openssl.'] }
    require 'openssl.so'
    k = OpenSSL::PKey::RSA.new(#{mix_str(PUBLIC_KEY, 10, 10000)})
    id, e, ts, ex = k.public_decrypt(File.read(lpath)).split(',') rescue nil
    $config.data.merge!('.user_id' => id, '.edition' => flags)
    tex = ex.to_f > 0 ? Time.at(ex.to_f) : nil
    $config.data.merge!('.license_ts' => Time.at(ts.to_f), '.license_ex' => tex)
    te = #{edition.inspect}
    (id && (te == e || te.empty?) && (tex.nil? || Time.now < tex)) ? true : false rescue false
  RUBY
  encode_code(code, 20, 60).strip
end

def compile(path)
  code = File.read(path)
  lines = code.lines.each_with_object([]) do |line, r|
    next if line =~ /^\s*(#.*)?$/
    line.gsub!(/^\s+/, '')
    line.gsub!(LICENSE_REGEXP) { |s| license_checker($2.to_s.split(' ')) }
    r << line
  end
  code = lines.join

  RubyVM::InstructionSequence.compile(
    code, path, path
  ).to_binary
end

Dir.chdir(app_dir) do
  Dir[*%w{*.rb src/xjz/**/*.rb}].each do |path|
    next if path == 'src/xjz/loader.rb'
    rbdata[path] = compile(path)
  end
  puts "Compiled Ruby Code"

  Dir[*%w{src/static/**/* src/webviews/**/*}].each do |path|
    next if File.directory?(path)
    rbdata[path] = File.read(path)
  end
  puts "Saved JS and Templates"
end

data = rbdata.map do |k, v|
  is_utf8 = v.encoding == Encoding::UTF_8 ? 1 : 0
  [
    [1, k.bytesize].pack("CN"), k,
    [is_utf8, v.bytesize].pack("CN"), v.force_encoding('binary')
  ].join
end.join

out_path = File.join(app_dir, 'data')
n = 9 + rand(128)
data = [
  [n].pack('C'),
  Random.bytes(n),
  Zlib::Deflate.deflate(data),
  Random.bytes(n)
].join
File.write(out_path, data)

puts "Output #{out_path}"

puts 'Done'
